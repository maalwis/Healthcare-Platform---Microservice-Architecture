

| **Domain**                                    | **Current State**                                                                                                                                                                                                                                                                                                                                                                                                  | **Final Design**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| --------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **High‑Level & Event‑Driven Core**            | - Core services (Patient, Appointment, Staff, Pharmacy, Inventory, Billing & Claims, Notification, Audit Logging, Analytics) each expose REST APIs.<br/>- Synchronous inter‑service calls via Feign/WebClient implemented for Patient ↔ Appointment ↔ Billing & Claims ↔ Staff.<br/>- RabbitMQ in place but only basic publish/subscribe for a handful of events (e.g. `PatientRegistered`, `AppointmentCreated`). | - Hybrid communication: synchronous low‑latency checks via Feign/WebClient + Resilience4j; asynchronous integration via RabbitMQ with a Schema Registry enforcing Avro/JSON schemas on every domain event.<br/>- Full end‑to‑end event choreography: each service emits and consumes all relevant events (e.g. `MedicationDispensed`, `StockReplenished`, `InvoiceGenerated`, `ClaimSubmitted`, etc.) with idempotent handlers.<br/>- All workflows (patient onboarding → billing → notification, prescription fill → inventory → audit) implemented asynchronously for loose coupling and scalability. |
| **Security & Authentication**                 | - JWT validation at the gateway (`AuthenticationGlobalFilter` implements `GlobalFilter, Ordered`).<br/>- Downstream services enforce JWT via `AuthTokenFilter` (Feign introspection).<br/>- Vault‑backed secrets (HashiCorp/AWS/Azure) injected via Spring Cloud Vault.<br/>- No mTLS, no secret vaulting, no token caching.                                                                                        | - Zero‑trust, defense‑in‑depth:<br/>  • Gateway + service filters both validate JWTs (via WebClient & Feign) with Redis‑backed introspection cache.<br/>  • All inter‑service traffic over mTLS in Istio STRICT mode.<br/>  • Vault‑backed secrets (HashiCorp/AWS/Azure) injected via Spring Cloud Vault.<br/>  • Role‑based access control annotations in each service for fine‑grained RBAC.                                                                                                                                                                                                          |
| **API Gateway & Rate Limiting**               | - Single Spring Cloud Gateway instance with two `GlobalFilter, Ordered` implementations:<br/>  • `AuthenticationGlobalFilter` validates JWTs. <br/>  • `RateLimitGlobalFilter` uses in‑memory `ConcurrentMap<String,Bucket>`. <br/>- Static, hard‑coded quotas; no distributed enforcement.                                                                                                                        | - Stateless, horizontally scalable gateway:<br/>  • Same two `GlobalFilter, Ordered` beans for auth & rate‑limit.<br/>  • Distributed rate limiting with Bucket4j + Redis adapter for global token buckets.<br/>  • Dynamic quotas stored in Spring Cloud Config, refreshed via `@RefreshScope`.<br/>  • Zone‑aware load balancing + configurable retry/backoff in gateway filter for resilience.<br/>  • Future support for canary routing and traffic shifting (e.g. via Istio VirtualServices).                                                                                                      |
| **Service Registry & Resilience**             | - Eureka registry + health checks on `/actuator/health`.<br/>- Spring Cloud LoadBalancer for client‑side discovery. <br/>- No Resilience4j circuit breakers, retries, or bulkheads currently.                                                                                                                                                                                                                      | - Enhanced fault‑tolerance:<br/>  • Resilience4j circuit breakers on all Feign/WebClient calls (configured thresholds, sliding windows).<br/>  • Bulkhead thread‑pool isolation per downstream client.<br/>  • Exponential‑backoff retries for idempotent operations.<br/>  • Fallback strategies (cached responses or default payloads) when circuits open.<br/>  • Automated health‑check routing and self‑healing via Kubernetes probes.                                                                                                                                                             |
| **Configuration & Dynamic Refresh**           | - Each service maintains its own static `application.properties`/`application.yml`.<br/>- No dynamic refresh; changes require redeploy.                                                                                                                                                                                                                                                                            | - Centralized Spring Cloud Config backed by Git + Vault:<br/>  • Profiles (`dev`, `staging`, `prod`) in Git.<br/>  • Sensitive values encrypted via Vault’s transit engine.<br/>  • Beans annotated with `@RefreshScope`; `/actuator/refresh` picks up new configs without restart.<br/>  • Git history provides an immutable audit trail of config changes.                                                                                                                                                                                                                                            |
| **CI/CD Pipeline**                            | - Per‑service branches trigger basic GitHub Actions:<br/>  • Compile JAR & build Docker image.<br/>  • Push image to Docker Hub as `${SERVICE_NAME}:${GITHUB_SHA}`.<br/>- Missing: static analysis, tests, security scans, artifact reuse, infra deployment.                                                                                                                                                       | - Branch‑per‑service, enterprise‑grade CI/CD:<br/>  1. **Build**: compile JAR once → store as artifact.<br/>  2. **Quality Gates**: Checkstyle, SpotBugs, PMD.<br/>  3. **Testing**: unit, Testcontainers integration, Pact contract tests.<br/>  4. **Security**: Trivy/Snyk scans Docker image.<br/>  5. **Containerize**: multi‑stage Docker build → non‑root JRE image.<br/>  6. **Publish**: push to Docker Hub; immutable tagging.<br/>  7. **(Future) Deploy**: Helm/Kustomize in infra repo → automated `helm upgrade`/`kubectl apply` → atomic rollbacks.                                      |
| **Observability (Logging, Metrics, Tracing)** | - No centralized logging (local console/files).<br/>- No Prometheus metrics.<br/>- No distributed tracing.<br/>- No alerting or SLO dashboards.                                                                                                                                                                                                                                                                    | - Full telemetry stack:<br/>  • JSON logs → Fluent Bit → Elasticsearch/Kibana (or Loki/Grafana).<br/>  • Micrometer metrics on `/actuator/prometheus`; Prometheus scrape + Grafana dashboards.<br/>  • Distributed tracing via Spring Cloud Sleuth/OpenTelemetry → Zipkin/Jaeger.<br/>  • Alertmanager rules for error spikes, latency breaches; Slack/PagerDuty notifications.<br/>  • SLO dashboards linked to runbooks.                                                                                                                                                                              |
| **Messaging & Event Governance**              | - RabbitMQ broker in place; basic publish/subscribe.<br/>- No TLS/auth on broker.<br/>- No schema registry, no DLQs, no retry policies.                                                                                                                                                                                                                                                                            | - Hardened event backbone:<br/>  • TLS + client‑cert auth for all RabbitMQ connections; vhost‑level permissions.<br/>  • Confluent (or Apicurio) Schema Registry for Avro/JSON schemas; versioned topics.<br/>  • Per‑queue DLQs with exponential‑backoff retry; “parking‑lot” queue for poison messages.<br/>  • Idempotent consumer handlers keyed by event ID to guarantee at‑least‑once semantics.                                                                                                                                                                                                  |
| **Data Consistency & Transactions**           | - No distributed transaction or saga orchestration.<br/>- All services update their own databases; no read models for search/analytics.                                                                                                                                                                                                                                                                            | - Event‑driven sagas & CQRS:<br/>  • Choreographed Sagas for multi‑step workflows (appointment → billing → notification) with compensating events (e.g. `AppointmentCancelled`).<br/>  • Dedicated read models (Elasticsearch, Redis) maintained via event consumers for patient search and analytics dashboards.                                                                                                                                                                                                                                                                                       |
| **Testing Strategy**                          | - Unit tests for core logic.<br/>- No integration, contract, end‑to‑end, or chaos tests.                                                                                                                                                                                                                                                                                                                           | - Layered test suite:<br/>  • Unit tests for all services.<br/>  • Integration tests via Testcontainers for real DB & broker.<br/>  • Pact consumer‑driven contract tests in CI.<br/>  • End‑to‑end tests in staging cluster covering full user journeys.<br/>  • Chaos engineering (Chaos Monkey/LitmusChaos) to validate resilience under failure.                                                                                                                                                                                                                                                    |
| **Operational Excellence & Runbooks**         | - No Kubernetes health/readiness probes.<br/>- No resource limits or autoscaling.<br/>- No runbooks or documented recovery procedures.<br/>- No compliance‑grade audit logs beyond domain events.                                                                                                                                                                                                                  | - Production‑ready operations:<br/>  • K8s liveness/readiness probes on `/actuator/health` with custom indicators (DB, RabbitMQ, Redis).<br/>  • Resource requests/limits + HPAs based on CPU/memory or custom metrics (queue depth).<br/>  • Confluence‑hosted runbooks with step‑by‑step recovery for DB failover, broker outages, CI rollback.<br/>  • Immutable audit trail of domain events + config changes + security decisions for compliance (HIPAA, GDPR).                                                                                                                                    |

---
